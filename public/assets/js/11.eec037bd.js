(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{593:function(e,a,s){"use strict";s.r(a);var n=s(17),r=Object(n.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"使用redis实现分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用redis实现分布式锁"}},[e._v("#")]),e._v(" 使用redis实现分布式锁")]),e._v(" "),s("blockquote",[s("p",[e._v("同一操作系统下的线程竞态访问某一临界资源，我们可以使用锁来帮助我们达成目的，一些编程语言\n都会提供内置的锁库。但是当我们的执行线程并不运行在同一操作系统之下，单一实例下的锁机制就\n失效了，这种情况下，我们需要分布式锁机制来帮助我们协调管理线程之间的竞争。")])]),e._v(" "),s("p",[e._v("我们可以在redis的帮助下实现分布式锁机制。只需要一条简单的命令我们便能做到它。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("set resource_name unique_value NX;\n")])])]),s("p",[e._v("在我们进入临界区之前，先尝试着向redis中插入一条数据，若该数据存在则获取锁失败，否则获取\n锁成功。不过这里有一个问题，就是若获取锁的线程在释放锁之前挂了，那么锁就无法被释放，其他线程\n也就没有办法获取到锁。为了解决这个问题，我们可以将unique_value设置为"),s("code",[e._v("expire_timestamp")]),e._v("，\n另外的线程可以get到"),s("code",[e._v("expire_timestamp")]),e._v("，若该时间戳小于当前时间戳，我们便可以执行del命令进而\n释放到锁，再执行获取锁的指令，就ok了。然而虽解决了锁无法释放的问题，却引入了新的问题。这里\n我们假设有两个线程在同一时刻检测到了锁失效，然后相继执行释放锁加锁的步骤，像下面这样：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("Thread 1:del resource_name;\nThread 1:set resource_name unique_value NX;\nThread 2:del resource_name;\nThread 2:set resource_name unique_value NX;\n")])])]),s("p",[e._v("最终Thread1和Thead2都获得了锁，违反了分布式锁的含义。因此相应的，我们不应该将释放锁的权力\n交给其他线程。释放锁的工作应当由获取锁的线程去做，若该线程挂了，那么该锁应当超时自动释放，redis\n同样提供了这样的机制，将上面的改一改：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("set resource_name unique_value NX EX expire_time;\n")])])]),s("p",[e._v("即使获取锁的线程挂了，该锁也能够在超时之后释放掉。但是呢，这个命令还是有问题。假设这把锁被超时释放了，\n另外的线程又获取到了这把锁，然而之前获取锁的线程并没有挂掉，它只是执行的比较慢而已，在另一个线程获取锁\n之后它才执行释放锁的操作，然后它就把其他线程的锁给释放掉了。显然这是不符合逻辑的，上面就提到没有把持锁\n的线程没有释放锁的权力，那么这个时候unique_value就起到了作用，当我们获取锁的时候将键对应的值设为\n全局唯一的某个值，比如timestamp + clientId，然后我们可以写一段Lua脚本")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('if redis.call("get",KEY[1]) == ARGV[1]\nthen\n    return redis.call("del",KEY[1])\nelse\n    return 0\nend\n')])])]),s("p",[e._v("只有当对应的值与当前线程设的值一样时，当前线程才可以释放掉锁。redis内置的lua脚本解释器也保证了\n每段脚本执行的原子性，不必担心有其他意外发生。")]),e._v(" "),s("p",[e._v("这些看起来很美好，但是不幸的是，依旧存在问题。如果我们的redis是master-slave架构，某个时刻master挂了，\n由于master和slave之间是异步的，如果新选出来的master没有这条锁的记录，那么其他线程便能够获取到该锁。那么\n有没有什么办法可以解决这个问题呢，答案是有的，大名鼎鼎的redlock就是为此诞生的。由于精力有限，redlock的讨论\n就过段时间再说，这里先挖个坑。")])])}),[],!1,null,null,null);a.default=r.exports}}]);